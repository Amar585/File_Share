{"success":true,"instructions":[{"title":"1. Create the exec_sql function","description":"This function allows executing SQL statements through RPC calls","sql":"\nCREATE OR REPLACE FUNCTION public.exec_sql(query text)\nRETURNS jsonb\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path = public\nAS $$\nDECLARE\n  result jsonb;\nBEGIN\n  EXECUTE query;\n  result := '{\"success\": true}'::jsonb;\n  RETURN result;\nEXCEPTION WHEN OTHERS THEN\n  result := jsonb_build_object('success', false, 'error', SQLERRM);\n  RETURN result;\nEND;\n$$;\n\n-- Grant execute permission to authenticated users\nGRANT EXECUTE ON FUNCTION public.exec_sql(text) TO authenticated;\n"},{"title":"2. Create the user_settings table","description":"This table stores user privacy and notification settings","sql":"\nCREATE TABLE IF NOT EXISTS public.user_settings (\n  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),\n  two_factor_enabled BOOLEAN DEFAULT FALSE,\n  private_files_by_default BOOLEAN DEFAULT TRUE,\n  require_approval_for_access BOOLEAN DEFAULT TRUE,\n  email_notifications_enabled BOOLEAN DEFAULT TRUE,\n  push_notifications_enabled BOOLEAN DEFAULT TRUE,\n  language VARCHAR(50) DEFAULT 'english',\n  notification_types JSONB DEFAULT '{\"file_shared\": true, \"file_downloaded\": true, \"access_requested\": true}'::jsonb\n);\n\n-- Enable RLS\nALTER TABLE public.user_settings ENABLE ROW LEVEL SECURITY;\n\n-- Create policies\nCREATE POLICY \"Users can view their own settings\" \nON public.user_settings FOR SELECT \nUSING (auth.uid() = id);\n\nCREATE POLICY \"Users can update their own settings\" \nON public.user_settings FOR UPDATE \nUSING (auth.uid() = id);\n\nCREATE POLICY \"Users can insert their own settings\" \nON public.user_settings FOR INSERT \nWITH CHECK (auth.uid() = id);\n"},{"title":"3. Create the notifications table","description":"This table stores user notifications","sql":"\nCREATE TABLE IF NOT EXISTS public.notifications (\n  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW() NOT NULL,\n  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,\n  type VARCHAR(50) NOT NULL,\n  title TEXT NOT NULL,\n  message TEXT NOT NULL,\n  read BOOLEAN DEFAULT FALSE,\n  metadata JSONB\n);\n\n-- Enable RLS\nALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;\n\n-- Create policies\nCREATE POLICY \"Users can view their own notifications\" \nON public.notifications FOR SELECT \nUSING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can update their own notifications\" \nON public.notifications FOR UPDATE \nUSING (auth.uid() = user_id);\n\nCREATE POLICY \"Users can insert their own notifications\" \nON public.notifications FOR INSERT \nWITH CHECK (auth.uid() = user_id);\n\nCREATE POLICY \"Users can delete their own notifications\" \nON public.notifications FOR DELETE \nUSING (auth.uid() = user_id);\n"},{"title":"4. Fix storage bucket policies","description":"These policies control access to the files storage bucket","sql":"\n-- Drop any existing policies to avoid conflicts\nDROP POLICY IF EXISTS \"Allow public read access\" ON storage.objects;\nDROP POLICY IF EXISTS \"Allow authenticated users to upload files\" ON storage.objects;\nDROP POLICY IF EXISTS \"Allow users to download their own files\" ON storage.objects;\nDROP POLICY IF EXISTS \"Users can access their own files\" ON storage.objects;\nDROP POLICY IF EXISTS \"Anyone can read storage objects\" ON storage.objects;\nDROP POLICY IF EXISTS \"Users can upload their own files\" ON storage.objects;\nDROP POLICY IF EXISTS \"Users can update their own files\" ON storage.objects;\nDROP POLICY IF EXISTS \"Users can delete their own files\" ON storage.objects;\n\n-- Allow authenticated users to upload files\nCREATE POLICY \"Allow authenticated users to upload files\" \nON storage.objects FOR INSERT \nWITH CHECK (bucket_id = 'files' AND auth.role() = 'authenticated');\n\n-- Allow users to download their own files\nCREATE POLICY \"Allow users to download their own files\" \nON storage.objects FOR SELECT \nUSING (\n  bucket_id = 'files' AND \n  ((storage.foldername(name))[1] = auth.uid()::text \n  OR auth.role() = 'service_role')\n);\n\n-- Allow users to update their own files\nCREATE POLICY \"Users can update their own files\" \nON storage.objects FOR UPDATE \nUSING (\n  bucket_id = 'files' AND \n  (storage.foldername(name))[1] = auth.uid()::text\n);\n\n-- Allow users to delete their own files\nCREATE POLICY \"Users can delete their own files\" \nON storage.objects FOR DELETE \nUSING (\n  bucket_id = 'files' AND \n  (storage.foldername(name))[1] = auth.uid()::text\n);\n"},{"title":"5. Create trigger to auto-create user settings","description":"This creates user settings automatically for new users","sql":"\n-- Create function to initialize user settings on user creation\nCREATE OR REPLACE FUNCTION public.handle_new_user()\nRETURNS TRIGGER AS $$\nBEGIN\n  INSERT INTO public.user_settings (id)\n  VALUES (NEW.id);\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Create trigger for new users (if it doesn't exist)\nDROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;\nCREATE TRIGGER on_auth_user_created\n  AFTER INSERT ON auth.users\n  FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();\n  \n-- Backfill existing users without settings\nINSERT INTO public.user_settings (id)\nSELECT id FROM auth.users\nWHERE id NOT IN (SELECT id FROM public.user_settings);\n"}],"important_note":"These instructions need to be executed in the Supabase SQL Editor. You can access it through the Supabase Dashboard. Run them in the order provided for best results."}